From 090379ce47f158caa2706b28ba7fabae0bdc5fbf Mon Sep 17 00:00:00 2001
From: nferre <nferre@50fbe906-d41e-0410-8a96-31537896a350>
Date: Tue, 1 Jun 2010 13:58:44 +0000
Subject: [PATCH] input: atmel_tsadcc: introduce changes needed for at91sam9m10g45ek board

Introduce filter function in touchscreen driver.



git-svn-id: svn://rfolxts01.rfo.atmel.com/at91_sandbox/linux-2.6.x/branches/linux-2.6.30-at91@15229 50fbe906-d41e-0410-8a96-31537896a350
---
 drivers/input/touchscreen/atmel_tsadcc.c |   86 ++++++++++++++++++++++++++++--
 1 files changed, 82 insertions(+), 4 deletions(-)

diff --git a/drivers/input/touchscreen/atmel_tsadcc.c b/drivers/input/touchscreen/atmel_tsadcc.c
index 27ac912..0648b88 100644
--- a/drivers/input/touchscreen/atmel_tsadcc.c
+++ b/drivers/input/touchscreen/atmel_tsadcc.c
@@ -95,6 +95,7 @@
 #define PRESCALER_VAL(x)	((x) >> 8)
 
 #define ADC_DEFAULT_CLOCK	100000
+#define COUNT_MAX		20
 
 struct atmel_tsadcc {
 	struct input_dev	*input;
@@ -107,10 +108,47 @@ struct atmel_tsadcc {
 };
 
 static void __iomem		*tsc_base;
+static unsigned int		trigger_period;
 
 #define atmel_tsadcc_read(reg)		__raw_readl(tsc_base + (reg))
 #define atmel_tsadcc_write(reg, val)	__raw_writel((val), tsc_base + (reg))
 
+static unsigned int do_filter(unsigned int val[], int count, int needed) {
+	int i, j;
+	int max_delta, max_delta_index;
+	unsigned int average;
+
+	for (i = count; i > needed; i--) {
+		average = 0;
+		for (j = 0; j < i; j++)
+			average += val[j];
+		average /= i;
+
+		max_delta = 0;
+		max_delta_index = -1;
+		for (j = 0; j < i; j++) {
+			if (abs(val[j] - average) > max_delta) {
+				max_delta = abs(val[j] - average);
+				max_delta_index = j;
+			}
+		}
+
+		if (max_delta_index < 0)
+			return average;
+
+		if (max_delta_index < i - 1)
+			for (j = 0; j < i - max_delta_index; j++)
+				val[max_delta_index + j] = val[max_delta_index + j + 1];
+	}
+
+	average = 0;
+	for (i = 0; i < needed; i++)
+		average += val[i];
+	average /= needed;
+
+	return average;
+}
+
 static irqreturn_t atmel_tsadcc_interrupt(int irq, void *dev)
 {
 	struct atmel_tsadcc	*ts_dev = (struct atmel_tsadcc *)dev;
@@ -118,6 +156,7 @@ static irqreturn_t atmel_tsadcc_interrupt(int irq, void *dev)
 
 	unsigned int status;
 	unsigned int reg;
+	static int count = 0;
 
 	status = atmel_tsadcc_read(ATMEL_TSADCC_SR);
 	status &= atmel_tsadcc_read(ATMEL_TSADCC_IMR);
@@ -147,11 +186,13 @@ static irqreturn_t atmel_tsadcc_interrupt(int irq, void *dev)
 		atmel_tsadcc_write(ATMEL_TSADCC_IER,
 				   ATMEL_TSADCC_EOC(3) | ATMEL_TSADCC_NOCNT);
 		atmel_tsadcc_write(ATMEL_TSADCC_TRGR,
-				   ATMEL_TSADCC_TRGMOD_PERIOD | (0x0FFF << 16));
+				   ATMEL_TSADCC_TRGMOD_PERIOD | (trigger_period << 16));
+
+		count = 0;
 
 	} else if (status & ATMEL_TSADCC_EOC(3)) {
 		/* Conversion finished */
-
+#if defined(CONFIG_MACH_AT91SAM9G45EKES) || defined(CONFIG_MACH_AT91SAM9M10EKES)
 		if (ts_dev->bufferedmeasure) {
 			/* Last measurement is always discarded, since it can
 			 * be erroneous.
@@ -163,6 +204,7 @@ static irqreturn_t atmel_tsadcc_interrupt(int irq, void *dev)
 			input_sync(input_dev);
 		} else
 			ts_dev->bufferedmeasure = 1;
+#endif
 
 		/* Now make new measurement */
 		ts_dev->prev_absx = atmel_tsadcc_read(ATMEL_TSADCC_CDR3) << 10;
@@ -170,8 +212,31 @@ static irqreturn_t atmel_tsadcc_interrupt(int irq, void *dev)
 
 		ts_dev->prev_absy = atmel_tsadcc_read(ATMEL_TSADCC_CDR1) << 10;
 		ts_dev->prev_absy /= atmel_tsadcc_read(ATMEL_TSADCC_CDR0);
-	}
 
+#if defined(CONFIG_MACH_AT91SAM9M10G45EK)
+		{
+		static unsigned int point_buffer_x[COUNT_MAX];
+		static unsigned int point_buffer_y[COUNT_MAX];
+
+		if (count < COUNT_MAX) {
+			point_buffer_x[count] = ts_dev->prev_absx;
+			point_buffer_y[count] = ts_dev->prev_absy;
+			count++;
+		} else {
+			unsigned int x, y;
+
+			count = 0;
+			x = do_filter(point_buffer_x, COUNT_MAX, COUNT_MAX * 3 / 4);
+			y = do_filter(point_buffer_y, COUNT_MAX, COUNT_MAX * 3 / 4);
+			input_report_abs(input_dev, ABS_X, x);
+			input_report_abs(input_dev, ABS_Y, y);
+			input_report_key(input_dev, BTN_TOUCH, 1);
+			input_report_abs(input_dev, ABS_PRESSURE, 7500);
+			input_sync(input_dev);
+		}
+		}
+#endif
+	}
 	return IRQ_HANDLED;
 }
 
@@ -188,6 +253,7 @@ static int __devinit atmel_tsadcc_probe(struct platform_device *pdev)
 	int		err = 0;
 	unsigned int	prsc;
 	unsigned int	reg;
+	unsigned int	startup_time;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
@@ -276,6 +342,18 @@ static int __devinit atmel_tsadcc_probe(struct platform_device *pdev)
 
 	prsc = (prsc / (2 * pdata->adc_clock)) - 1;
 
+#if defined(CONFIG_MACH_AT91SAM9M10G45EK)
+	trigger_period = pdata->adc_clock / (200 * COUNT_MAX) -1;
+	if (trigger_period < 1)
+		trigger_period = 1;
+	startup_time = (60 * pdata->adc_clock) / (8 * 1000000) - 1;
+	if (startup_time < 1)
+		startup_time = 1;
+#else
+	trigger_period =  0x0FFF;
+	startup_time = 0x26;
+#endif
+
 	/* saturate if this value is too high */
 	if (cpu_is_at91sam9rl()) {
 		if (prsc > PRESCALER_VAL(ATMEL_TSADCC_PRESCAL))
@@ -291,7 +369,7 @@ static int __devinit atmel_tsadcc_probe(struct platform_device *pdev)
 		((0x00 << 5) & ATMEL_TSADCC_SLEEP)	|	/* Normal Mode */
 		((0x01 << 6) & ATMEL_TSADCC_PENDET)	|	/* Enable Pen Detect */
 		(prsc << 8)				|
-		((0x26 << 16) & ATMEL_TSADCC_STARTUP)	|
+		((startup_time << 16) & ATMEL_TSADCC_STARTUP)	|
 		((pdata->pendet_debounce << 28) & ATMEL_TSADCC_PENDBC);
 
 	atmel_tsadcc_write(ATMEL_TSADCC_CR, ATMEL_TSADCC_SWRST);
-- 
1.5.6.5

